# JS
## 构造函数
new运算符
1. 创建一个新的空对象实例。
2. 将此空对象的隐式原型指向其构造函数的显示原型。
3. 执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。
4. 如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。
## 原型及原型链
### 原型概念
每个函数都有一个prototype属性,它指向了一个对象,这个对象里的所有方法和属性都会被构造函数的实例继承, 这个对象就称为原型对象.
### 原型链
每个对象都有一个指向其原型对象的指针,对象从原型中继承方法和属性.每个原型对象又有自己的原型,并从中继承方法和属性,直到某个对象的原型为null为止,这种关系被称为原型链
````
function F1() {}
function F2() {}
function F3() {}

let f1 = new F1();
let f2 = new F2();
let f3 = new F3();

F2.prototype = f1;
F3.prototype = f2;

````
### 为什么需要原型链
1. 用构造函数生成的实例,都有自己的方法和属性

## 继承
1. 构造函数继承
````
    function Parent1() {
        this.name = 'parent1 的属性';
    }

    function Child1() {
        Parent1.call(this);         //【重要】此处用 call 或 apply 都行：改变 this 的指向
        this.type = 'child1 的属性';
    }

    console.log(new Child1);
````
让父类构造函数使用call在子类构造函数里执行,改变父类的this指向. 缺点是父类原型上的方法和属性不能被继承

2. 原型链继承
````
    function Parent() {
        this.name = 'Parent 的属性';
    }

    function Child() {
        this.type = 'Child 的属性';
    }

    Child.prototype = new Parent(); //【重要】

    console.log(new Child());
````
将子类的原型指向父类的实例,借助原型链实现继承,缺点是子类的多个实例共用父类原型,无法隔离

3. 组合继承 通过call调用父类构造函数,然后将子类的原型指向父类的实例,缺点是父类构造函数调用两次
4. 
5. 寄生组合继承
原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。
构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，构造继承可以向父类传递参数，可以实现多继承，通过call多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能
实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承
拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用for in访问到）
组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
## 数组方法
  1. filter()
    * filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
    * 注意： filter() 不会对空数组进行检测。
    * 注意： filter() 不会改变原始数组。
  ```
    var words = ["spray", "limit", "elite", "exuberant", "destruction", "present"];
    var longWords = words.filter(function(word){
      return word.length > 6;
    });
    // Filtered array longWords is ["exuberant", "destruction", "present"]
  ```

### 复制数组
  1. concat()
  ```
  const a1 = [1, 2];
  const a2 = a1.concat();

  a2[0] = 2;
  a1 // [1, 2]
  ```
  2. es6扩展运算符
  ```
  const a1 = [1, 2];
  // 写法一
  const a2 = [...a1];
  // 写法二
  const [...a2] = a1;
  ```
### 合并数组
  1. concat()
     `[1, 2].concat(more)`
  2. es6扩展运算符
  ```
  var arr1 = ['a', 'b'];
  var arr2 = ['c'];
  var arr3 = [...arr1, ...arr2]
  ```
### 数组去重
  1. [...new Set(array)]
